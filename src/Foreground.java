/*Name: Xin Lu
 * NetID: xlu32
 * Assign_Num: Project 04
 * Lab section: TR 12:30pm - 01:45 pm
*/

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.awt.image.RescaleOp;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.Timer;
import javax.swing.WindowConstants;

public class Foreground extends JComponent{
	
	private List<Hill> hills = new ArrayList<>();
	private Timer timer;
	private int totalWidth;	//this variable stores the total width of all hills in the list
	//this variable check if the foreground hinder the player
	private boolean isHinder = false;
	private boolean hasPowerUp = false;	//we want this boolean for the whole foreground since we only have one
										//power up for entire game
	
	private BufferedImage castle;
	
	private int castlePos;	//this return the castle position and thus help check if the player win
	
	private int top, num;	//this variable store the top position of the hill at certain x
	
	private RescaleOp op = new RescaleOp(.5f, 0, null);
	
	
	public Foreground(int num){
		this.num = num;
		
		//whenever we create a foreground, we initialize a new list of hills
		this.totalWidth = 0;	//at first the total width is 0
		
		//the below loop create certain numbers of hills
		Random gene = new Random();	//this help to generate gap
		//this is a temporary variable that judge whether or not to make a gap
		//the first few place should not have a gap
		int index = gene.nextInt(4) + 4;	//plus one since player should not start on a gap
		int index2 = gene.nextInt(20);	//this index is used to see if a hill contains a monster
										//so there is 3/10 of the possibility for a montain to have a monster
		
		int count = 0;	//this help counts how many 5 hills groups are being created
		//these two variable store the changing position of the hills

		//this make sure that each map has around 6200-6600's pixel's width
		while(this.totalWidth <= 6400){	//so we make the whole map ten times the width of windows
			//we use the total Width here directly since the next hill being created will be attached
			//to the latest hill, whose end line has x position equals to totalWidth
			Hill temp = new Hill(this.totalWidth, 455, num);	//create a new hill
			
			//notice the hills.size() here represents the index the temp will be given, since it is going to 
			//be the next element added in
			//the second segement ensure the gap will not appear at the end of the game
			if((hills.size()) == index && this.totalWidth <= 6000){	//so the #of element generated by index is reached
				temp.setGap();	//set the corresponding element as the gap
				count ++;	//since we have already make a gap, we need to move to the next group, so group++
				//generate a new index
				//so the next index being made as gap will be within 6 - 9, by doing so we can avoid
				//two gaps come next to each other and ensure that each 5 group yields one gap
				index = count * 5 + gene.nextInt(4) + 4;
			}
			//only when the hill is not a gap, will it contains a monster
			//and also the monster must not occur so quick so that player has time to prepare for that
			else if(index2 < 3 && this.totalWidth >= 400){
				temp.addMonster();
			}
			
			//if non of the above happens, it will be possible for us to add a mushroom that allow double jump
			//and only when the map has run almost half will we add a powerUp mushroom
			else if(index2 < 8 && this.totalWidth >= 3500 && !this.hasPowerUp){
				temp.addMonster();	//add a monster type to the hill
				if(temp.getMonster() != null){	//in case that the monster is not created successfully
					temp.getMonster().isPowerUp();
					//if we successfully add a mushroom to the program
					this.hasPowerUp = true;
				}
			}
			//if until the map has almost be done there is no powerup, defaultly set a powerup mushroom
			else if(!this.hasPowerUp && this.totalWidth >= 5000){
				temp.addMonster();	//add a monster type to the hill
				if(temp.getMonster() != null){	//in case that the monster is not created successfully
					temp.getMonster().isPowerUp();
					//if we successfully add a mushroom to the program
					this.hasPowerUp = true;
				}
			}
			//cases that the map could generate a coin
			else if(this.totalWidth >= 200 && this.totalWidth <= 6000){
				temp.addMonster();
				if(temp.getMonster() != null){	//same logic as above
					temp.getMonster().isCoin();	//set the coin
				}
			}
			
			//since it is possible that the first generated index2 is not less than 3, and for every
			//hill we need such index, we regenerate the index every once the while loop is executed
			index2 = gene.nextInt(20);	//generate a new index
			
			this.hills.add(temp);	//we add the temp object to the array list
			this.totalWidth += temp.getWidth();
		}
		
		//get the castle image
		try {
			this.castle = ImageIO.read(new File("Picture/Castle.png"));
		} catch (IOException e) {
			System.out.print("You do not have this image in the folder.");
		}
		
	}
	
	//this method returns the castle position
	public int getCastlePos(){
		return this.castlePos;
	}
	
	//this method tell all monsters that the player is someone they need to detect and see if killed
	public void setPlayer(Player player){
		this.hills.forEach((temp)->{
			if(temp.ifHasMonster()){
				temp.getMonster().setPlayer(player);	//tell the monster who the player is
			}
		});
	}
	
	private Hill aHill;
	//get the height of hill at player's position
	public Hill getIndex(int index){	//takes in the x position of the player
		//check the hill at this x position
		this.hills.forEach((temp)->{
			if(temp.inWidthRange(index)){
				this.aHill = temp;
			}
		});
		return this.aHill;	//return the top height
	}
	
	//get the height of hill at player's position
	public int getTop(int x){	//takes in the x position of the player
		this.top = -1;	//whenever we check, starts with a small top
		this.hills.forEach((temp)->{
			if(temp.inWidthRange(x)){
				this.top = temp.getTopY();
			}
		});
		return this.top;	//return the top height
	}
	
	//this method move all hills including gap in the list to the left
	public void move(int aNum){
		this.hills.forEach((temp)->{
			temp.move(aNum);
		});
	}
	
	//this method return a boolean to see if we reaches the end of the map
	public boolean stop(){
		Hill last = this.hills.get(this.hills.size() - 1);	//get the last hill in the game
		int endEdge = last.getX() + last.getWidth();
		//we use 650 here, so there should have more map not enter the game
		//but since we do not want gap to be there, we make an extra 10 pixel to ensure the whole window
		//has graphics and picture
		if(endEdge <= 650){
			return true;	//if the endEdge is smaller than 650, stop scrolling
		}
		else{
			return false;
		}
	}
	
	
	//this method check if the player's current position is blocked by component of the hill
	public boolean isHinder(int x, int y){
		//do modification for the parameter taken in as we want to check the future position of the player
		//since the player's front is 50 away from its x position, we add 50, and because we want the future
		//position will add one more to the lateX
		int lateX = x + 50;	
		int lateY = y + 49;	//since the bottom line of the player needs y + 50
		//whenever we start to check if the player is hindered, we set the boolean to true at first
		this.isHinder = false;
		
		//get the iterator of the array list hills
		this.hills.forEach((temp)->{
			if(temp.rightBefore(lateX)){	//check which hill we should be checking
				//this means the player has a y position below the hill's top
				if(!(temp.inHeightRange(lateY))){
					//only when a player can stood on some hill's top one pixel later will this method
					//return false, meaning the player is not hindered
					this.isHinder = true;	
				}
			}
		});
		
		return this.isHinder;
	}

	
	public void paintComponent(Graphics g){
		//System.out.print("Should paint");
		//we draw every hills in the array list
		this.hills.forEach((temp)->{
			temp.paintComponent(g);
			if(temp.ifHasMonster()){
				//first run this method to see if the monster is still alive
				temp.getMonster().ifKill();	//running this method will update the situation of the monster
				//then the monster will automatically judge, in its paintComponent method, that should
				//it draws itself
				temp.getMonster().paintComponent(g);
			}
		});
		
		//get the last hill of the map
		Hill last = this.hills.get(this.hills.size() - 1);
		int h = last.getTopY() - 89;	//get the top y coordinate of the hill and since the picture itself
										//has a height, substract 89(as y is smaller if more above)
		//make the castle center at the mid point of the last hill
		//and make sure the castle's ends touch the end of the frame
		int x = last.getX() + (last.getWidth() - 75);	//get the x position of the last hill
		
		this.castlePos = x;
		
		//then draw the castle on the last hill
		g.drawImage(this.castle, x, h, 75, 89, this);
		
	}
	
	//get the preferred size of the whole foreground
	public Dimension getPreferredSize(){
		return new Dimension(640, 480);
	}
	
	
	//tester class
	public static void main(String[] args){
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
		frame.setSize(640, 480);
		frame.setVisible(true);
	}
	
}
